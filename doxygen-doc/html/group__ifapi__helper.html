<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tpm2-tss: Helper functions module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tpm2-tss
   &#160;<span id="projectnumber">4.0.1-44-g8699ab39</span>
   </div>
   <div id="projectbrief">TPM Software stack 2.0 TCG spec compliant implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ifapi__helper.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Helper functions module<div class="ingroups"><a class="el" href="group__fapi.html">Feature API</a> &raquo; <a class="el" href="group__ifapi.html">Internals of Feature API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1f8e0c2e9df6f38b501d21fc07e88cd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga1f8e0c2e9df6f38b501d21fc07e88cd9">add_string_to_list</a> (<a class="el" href="structstr__node.html">NODE_STR_T</a> *str_list, char *string)</td></tr>
<tr class="separator:ga1f8e0c2e9df6f38b501d21fc07e88cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9b1f09175ad753322be151d5eee2b0"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga4f9b1f09175ad753322be151d5eee2b0">append_object_to_list</a> (void *object, <a class="el" href="structobject__node.html">NODE_OBJECT_T</a> **object_list)</td></tr>
<tr class="separator:ga4f9b1f09175ad753322be151d5eee2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b21d3fc2e1b2ee0c09f12b269d9e293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga2b21d3fc2e1b2ee0c09f12b269d9e293">free_string_list</a> (<a class="el" href="structstr__node.html">NODE_STR_T</a> *node)</td></tr>
<tr class="separator:ga2b21d3fc2e1b2ee0c09f12b269d9e293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07c49eace5081c15205743b658a3386"><td class="memItemLeft" align="right" valign="top"><a id="gab07c49eace5081c15205743b658a3386"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_description</b> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *object)</td></tr>
<tr class="separator:gab07c49eace5081c15205743b658a3386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6ef478fc320da700c58b4438400c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga8d6ef478fc320da700c58b4438400c07">ifapi_TPM2B_DIGEST_cmp</a> (TPM2B_DIGEST *in1, TPM2B_DIGEST *in2)</td></tr>
<tr class="separator:ga8d6ef478fc320da700c58b4438400c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d10d7b329dba2cb5ee8400860e14dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga86d10d7b329dba2cb5ee8400860e14dd">ifapi_TPM2B_ECC_PARAMETER_cmp</a> (TPM2B_ECC_PARAMETER *in1, TPM2B_ECC_PARAMETER *in2)</td></tr>
<tr class="separator:ga86d10d7b329dba2cb5ee8400860e14dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bdb7752a2540102271a76e7e8b6ab0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gad9bdb7752a2540102271a76e7e8b6ab0">ifapi_TPM2B_PUBLIC_KEY_RSA_cmp</a> (TPM2B_PUBLIC_KEY_RSA *in1, TPM2B_PUBLIC_KEY_RSA *in2)</td></tr>
<tr class="separator:gad9bdb7752a2540102271a76e7e8b6ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b6fe34ea1c69e392dfd088fad80166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga66b6fe34ea1c69e392dfd088fad80166">ifapi_TPMS_ECC_POINT_cmp</a> (TPMS_ECC_POINT *in1, TPMS_ECC_POINT *in2)</td></tr>
<tr class="separator:ga66b6fe34ea1c69e392dfd088fad80166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00af0193f671174e217ac6be45254aa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga00af0193f671174e217ac6be45254aa3">ifapi_TPMT_PUBLIC_cmp</a> (TPMT_PUBLIC *in1, TPMT_PUBLIC *in2)</td></tr>
<tr class="separator:ga00af0193f671174e217ac6be45254aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238cee88773a3aadffac8661be198796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga238cee88773a3aadffac8661be198796">ifapi_TPMU_PUBLIC_ID_cmp</a> (TPMU_PUBLIC_ID *in1, UINT32 selector1, TPMU_PUBLIC_ID *in2, UINT32 selector2)</td></tr>
<tr class="separator:ga238cee88773a3aadffac8661be198796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacac32b76a99d84b367ba95a369099813"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gacac32b76a99d84b367ba95a369099813">ifapi_asprintf</a> (char **str, const char *fmt,...)</td></tr>
<tr class="separator:gacac32b76a99d84b367ba95a369099813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b1bbf28c37eb03b27d2ee03448345e"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga58b1bbf28c37eb03b27d2ee03448345e">ifapi_calculate_pcr_digest</a> (json_object *jso_event_list, const <a class="el" href="struct_f_a_p_i___q_u_o_t_e___i_n_f_o.html">FAPI_QUOTE_INFO</a> *quote_info, TPM2B_DIGEST *pcr_digest)</td></tr>
<tr class="separator:ga58b1bbf28c37eb03b27d2ee03448345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22b8182e2530968184052436906d8a5"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gac22b8182e2530968184052436906d8a5">ifapi_check_profile_pcr_selection</a> (const TPML_PCR_SELECTION *pcr_profile, const TPML_PCR_SELECTION *pcr_capablity)</td></tr>
<tr class="separator:gac22b8182e2530968184052436906d8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87019bf837cb3a5ecf33d1bfab11f41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gab87019bf837cb3a5ecf33d1bfab11f41">ifapi_cleanup_policy</a> (<a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> *policy)</td></tr>
<tr class="separator:gab87019bf837cb3a5ecf33d1bfab11f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae32a95768059bd8c1a36ae83ff12e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga8ae32a95768059bd8c1a36ae83ff12e1">ifapi_cmp_public_key</a> (TPM2B_PUBLIC *key1, TPM2B_PUBLIC *key2)</td></tr>
<tr class="separator:ga8ae32a95768059bd8c1a36ae83ff12e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac8d5bbcca780c307f47f2c993e806a"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga5ac8d5bbcca780c307f47f2c993e806a">ifapi_compute_policy_digest</a> (TPML_PCRVALUES *pcrs, TPML_PCR_SELECTION *pcr_selection, TPMI_ALG_HASH hash_alg, TPM2B_DIGEST *pcr_digest)</td></tr>
<tr class="separator:ga5ac8d5bbcca780c307f47f2c993e806a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fb35f081f18d75170cb6b304c508e7"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga94fb35f081f18d75170cb6b304c508e7">ifapi_compute_quote_info</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *sig_key_object, TPM2B_ATTEST *tpm_quoted, char **quoteInfo)</td></tr>
<tr class="separator:ga94fb35f081f18d75170cb6b304c508e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2594c1a26a3b169c3256cd6835138b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga2594c1a26a3b169c3256cd6835138b2a">ifapi_copy_policy</a> (const <a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> *from_policy)</td></tr>
<tr class="separator:ga2594c1a26a3b169c3256cd6835138b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44614f72af8b4a5f3d1184fc047dbfa"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gad44614f72af8b4a5f3d1184fc047dbfa">ifapi_create_dirs</a> (const char *supdir, const char *path)</td></tr>
<tr class="separator:gad44614f72af8b4a5f3d1184fc047dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5cb7f72dcfe7a40f7d85f59d4a2da6f"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gad5cb7f72dcfe7a40f7d85f59d4a2da6f">ifapi_extend_vpcr</a> (TPM2B_DIGEST *vpcr, TPMI_ALG_HASH bank, const <a class="el" href="struct_i_f_a_p_i___e_v_e_n_t.html">IFAPI_EVENT</a> *event)</td></tr>
<tr class="separator:gad5cb7f72dcfe7a40f7d85f59d4a2da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468cc3feb1cd0f5055824e2c63f2393c"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga468cc3feb1cd0f5055824e2c63f2393c">ifapi_filter_pcr_selection_by_index</a> (TPML_PCR_SELECTION *pcr_selection, const TPM2_HANDLE *pcr_index, size_t pcr_count)</td></tr>
<tr class="separator:ga468cc3feb1cd0f5055824e2c63f2393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6dc3ed8ed2ca9dc76a41efa4806f83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gab6dc3ed8ed2ca9dc76a41efa4806f83e">ifapi_free_node_list</a> (<a class="el" href="structobject__node.html">NODE_OBJECT_T</a> *node)</td></tr>
<tr class="separator:gab6dc3ed8ed2ca9dc76a41efa4806f83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6797d934eb61443e545844db65ae5f72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga6797d934eb61443e545844db65ae5f72">ifapi_free_object_list</a> (<a class="el" href="structobject__node.html">NODE_OBJECT_T</a> *node)</td></tr>
<tr class="separator:ga6797d934eb61443e545844db65ae5f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b9617854be3d5bb2d8e0de2bf04ec8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gaf2b9617854be3d5bb2d8e0de2bf04ec8">ifapi_get_curl_buffer</a> (unsigned char *url, unsigned char **buffer, size_t *buffer_size)</td></tr>
<tr class="separator:gaf2b9617854be3d5bb2d8e0de2bf04ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8ce715f4021037bc39fc1f7eb8279e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___e_s_y_s___t_r.html#ga65d10db3b0b31fcd709e692f1545d30f">ESYS_TR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gadb8ce715f4021037bc39fc1f7eb8279e">ifapi_get_hierary_handle</a> (const char *path)</td></tr>
<tr class="separator:gadb8ce715f4021037bc39fc1f7eb8279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034274af7fde7ae684afd4b5b3237b26"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga034274af7fde7ae684afd4b5b3237b26">ifapi_get_name</a> (TPMT_PUBLIC *publicInfo, TPM2B_NAME *name)</td></tr>
<tr class="separator:ga034274af7fde7ae684afd4b5b3237b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455326d26b311603d9da63efe79a4dd3"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga455326d26b311603d9da63efe79a4dd3">ifapi_get_nv_start_index</a> (const char *path, TPM2_HANDLE *start_nv_index)</td></tr>
<tr class="separator:ga455326d26b311603d9da63efe79a4dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00fd6284ca121583aca052a56f1a2d4"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gaa00fd6284ca121583aca052a56f1a2d4">ifapi_get_quote_info</a> (char const *quoteInfo, TPM2B_ATTEST *tpm_quoted, <a class="el" href="struct_f_a_p_i___q_u_o_t_e___i_n_f_o.html">FAPI_QUOTE_INFO</a> *fapi_quote_info)</td></tr>
<tr class="separator:gaa00fd6284ca121583aca052a56f1a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e34498859d879598ddc08a66f15403a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga7e34498859d879598ddc08a66f15403a">ifapi_hierarchy_path_p</a> (const char *path)</td></tr>
<tr class="separator:ga7e34498859d879598ddc08a66f15403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93336bf06e87954a0e5ddc1616f9e377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga93336bf06e87954a0e5ddc1616f9e377">ifapi_init_hierarchy_object</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *hierarchy, <a class="el" href="group___e_s_y_s___t_r.html#ga65d10db3b0b31fcd709e692f1545d30f">ESYS_TR</a> esys_handle)</td></tr>
<tr class="separator:ga93336bf06e87954a0e5ddc1616f9e377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7667bcd54362a38007d58a2918f7635"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gab7667bcd54362a38007d58a2918f7635">ifapi_object_cmp_name</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *object, void *name, bool *equal)</td></tr>
<tr class="separator:gab7667bcd54362a38007d58a2918f7635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cd01f29bf9c4c9535649dd73673ec3"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga87cd01f29bf9c4c9535649dd73673ec3">ifapi_object_cmp_nv_public</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *object, void *nv_public, bool *equal)</td></tr>
<tr class="separator:ga87cd01f29bf9c4c9535649dd73673ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1c16328644d62953d4d4836fa95757"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gabb1c16328644d62953d4d4836fa95757">ifapi_path_length</a> (<a class="el" href="structstr__node.html">NODE_STR_T</a> *node)</td></tr>
<tr class="separator:gabb1c16328644d62953d4d4836fa95757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293580897a76b7519bf018470f3b2171"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga293580897a76b7519bf018470f3b2171">ifapi_path_string</a> (char **dest, const char *supdir, <a class="el" href="structstr__node.html">NODE_STR_T</a> *node, char *name)</td></tr>
<tr class="separator:ga293580897a76b7519bf018470f3b2171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2161b653a989bab810dc4a9bebb927e"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gad2161b653a989bab810dc4a9bebb927e">ifapi_path_string_n</a> (char **dest, const char *supdir, <a class="el" href="structstr__node.html">NODE_STR_T</a> *node, char *name, size_t n)</td></tr>
<tr class="separator:gad2161b653a989bab810dc4a9bebb927e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75cd413d178c3fe513d416d1d3eab11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gaf75cd413d178c3fe513d416d1d3eab11">ifapi_path_type_p</a> (const char *path, const char *type)</td></tr>
<tr class="separator:gaf75cd413d178c3fe513d416d1d3eab11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f3965b173b6c0e863ce294f1a4b97"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gac76f3965b173b6c0e863ce294f1a4b97">ifapi_set_key_flags</a> (const char *type, bool policy, <a class="el" href="struct_i_f_a_p_i___k_e_y___t_e_m_p_l_a_t_e.html">IFAPI_KEY_TEMPLATE</a> *template)</td></tr>
<tr class="separator:gac76f3965b173b6c0e863ce294f1a4b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27f2e42fb41260ab89262854aae7077e"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga27f2e42fb41260ab89262854aae7077e">ifapi_set_nv_flags</a> (const char *type, <a class="el" href="struct_i_f_a_p_i___n_v___t_e_m_p_l_a_t_e.html">IFAPI_NV_TEMPLATE</a> *template, const char *policy)</td></tr>
<tr class="separator:ga27f2e42fb41260ab89262854aae7077e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fac7d0a838e596df0f0685bddf2fff"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga63fac7d0a838e596df0f0685bddf2fff">ifapi_tpm_to_fapi_signature</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *sig_key_object, TPMT_SIGNATURE *tpm_signature, uint8_t **signature, size_t *signatureSize)</td></tr>
<tr class="separator:ga63fac7d0a838e596df0f0685bddf2fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66902b2561636af5a982927d5aef44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gab66902b2561636af5a982927d5aef44d">init_string_list</a> (const char *string)</td></tr>
<tr class="separator:gab66902b2561636af5a982927d5aef44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e845a3e57021fc1c25684718618075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga74e845a3e57021fc1c25684718618075">object_with_auth</a> (<a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *object)</td></tr>
<tr class="separator:ga74e845a3e57021fc1c25684718618075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0552a0622791311be53958ad74fbdec7"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga0552a0622791311be53958ad74fbdec7">push_object_to_list</a> (void *object, <a class="el" href="structobject__node.html">NODE_OBJECT_T</a> **object_list)</td></tr>
<tr class="separator:ga0552a0622791311be53958ad74fbdec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03902900f256d64ddfffaf393e8a093f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga03902900f256d64ddfffaf393e8a093f">split_string</a> (const char *string, char *delimiter)</td></tr>
<tr class="separator:ga03902900f256d64ddfffaf393e8a093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92db3457377cf6fa25ca10bfcc714b17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga92db3457377cf6fa25ca10bfcc714b17">vasprintf</a> (char **str, const char *fmt, va_list args)</td></tr>
<tr class="separator:ga92db3457377cf6fa25ca10bfcc714b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf736cff329e18f7450b544825c70250e"><td class="memItemLeft" align="right" valign="top">TSS2_RC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#gaf736cff329e18f7450b544825c70250e">ifapi_check_nv_index</a> (const char *path, TPM2_HANDLE nv_index)</td></tr>
<tr class="separator:gaf736cff329e18f7450b544825c70250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276eeabb66eb1eb9136234505536f23c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ifapi__helper.html#ga276eeabb66eb1eb9136234505536f23c">ifapi_null_primary_p</a> (const char *path)</td></tr>
<tr class="separator:ga276eeabb66eb1eb9136234505536f23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides helper functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f8e0c2e9df6f38b501d21fc07e88cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8e0c2e9df6f38b501d21fc07e88cd9">&#9670;&nbsp;</a></span>add_string_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool add_string_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td>
          <td class="paramname"><em>str_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add string to the last element of a linked list of strings.</p>
<p>A duplicate of the passed string will be added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str_list</td><td>The linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the string was added to the list. </td></tr>
    <tr><td class="paramname">false</td><td>if the list could not be extended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f9b1f09175ad753322be151d5eee2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9b1f09175ad753322be151d5eee2b0">&#9670;&nbsp;</a></span>append_object_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC append_object_to_list </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__node.html">NODE_OBJECT_T</a> **&#160;</td>
          <td class="paramname"><em>object_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a object as last element to a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object to be added. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">object_list</td><td>The linked list to be extended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the object was added. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>If memory for the list extension cannot be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b21d3fc2e1b2ee0c09f12b269d9e293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b21d3fc2e1b2ee0c09f12b269d9e293">&#9670;&nbsp;</a></span>free_string_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_string_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free linked list of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the first node of the linked list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacac32b76a99d84b367ba95a369099813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacac32b76a99d84b367ba95a369099813">&#9670;&nbsp;</a></span>ifapi_asprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to allocated string.</p>
<p>A list of parameters will be printed to an allocated string according to the format description in the first parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>The allocated output string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The format string (printf formats can be used.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>The list of objects to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the printing was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58b1bbf28c37eb03b27d2ee03448345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b1bbf28c37eb03b27d2ee03448345e">&#9670;&nbsp;</a></span>ifapi_calculate_pcr_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_calculate_pcr_digest </td>
          <td>(</td>
          <td class="paramtype">json_object *&#160;</td>
          <td class="paramname"><em>jso_event_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_a_p_i___q_u_o_t_e___i_n_f_o.html">FAPI_QUOTE_INFO</a> *&#160;</td>
          <td class="paramname"><em>quote_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_DIGEST *&#160;</td>
          <td class="paramname"><em>pcr_digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a event list corresponds to a certain quote information.</p>
<p>The event list is used to compute the PCR values corresponding to this event list. The PCR digest for these PCRs is computed and compared with the attest passed with quote_info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jso_event_list</td><td>The event list in JSON representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quote_info</td><td>The information structure with the attest. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcr_digest</td><td>The computed pcr_digest for the PCRs uses by FAPI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the PCR digest from the event list matches the PCR digest passed with the quote_info. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_SIGNATURE_VERIFICATION_FAILED</td><td>If the digest computed from event list does not match the attest </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If inappropriate values are detected in the input data. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an internal error occurred. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf736cff329e18f7450b544825c70250e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf736cff329e18f7450b544825c70250e">&#9670;&nbsp;</a></span>ifapi_check_nv_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ifapi_check_nv_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2_HANDLE&#160;</td>
          <td class="paramname"><em>nv_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether NV index is appropriate for NV path.</p>
<p>The value will be checked based on e TCG handle registry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path used for the NV object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nv_index</td><td>The NV index to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the index for the path can be determined. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_PATH</td><td>If the path is not valid. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If the nv index is not appropriate for the path. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac22b8182e2530968184052436906d8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22b8182e2530968184052436906d8a5">&#9670;&nbsp;</a></span>ifapi_check_profile_pcr_selection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_check_profile_pcr_selection </td>
          <td>(</td>
          <td class="paramtype">const TPML_PCR_SELECTION *&#160;</td>
          <td class="paramname"><em>pcr_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TPML_PCR_SELECTION *&#160;</td>
          <td class="paramname"><em>pcr_capablity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether profile PCR capabilities are a subset of TPM PCR capabilities.</p>
<p>It has to be checked that every hash alg from the profile is available and whether the selected PCRs are available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcr_profile</td><td>The pcr profile to use as basis for the selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcr_capablity</td><td>The PCR capabilities available for TPM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESSS</td><td>if the conversion was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if profile is not subset of capabilities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab87019bf837cb3a5ecf33d1bfab11f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab87019bf837cb3a5ecf33d1bfab11f41">&#9670;&nbsp;</a></span>ifapi_cleanup_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifapi_cleanup_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> *&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free memory allocated during deserialization of policy.</p>
<p>The object will not be freed (might be declared on the stack).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>The policy to be cleaned up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ae32a95768059bd8c1a36ae83ff12e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae32a95768059bd8c1a36ae83ff12e1">&#9670;&nbsp;</a></span>ifapi_cmp_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_cmp_public_key </td>
          <td>(</td>
          <td class="paramtype">TPM2B_PUBLIC *&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_PUBLIC *&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two public keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key1</td><td>The first key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key2</td><td>The second key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if equal false if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ac8d5bbcca780c307f47f2c993e806a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ac8d5bbcca780c307f47f2c993e806a">&#9670;&nbsp;</a></span>ifapi_compute_policy_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_compute_policy_digest </td>
          <td>(</td>
          <td class="paramtype">TPML_PCRVALUES *&#160;</td>
          <td class="paramname"><em>pcrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPML_PCR_SELECTION *&#160;</td>
          <td class="paramname"><em>pcr_selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMI_ALG_HASH&#160;</td>
          <td class="paramname"><em>hash_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_DIGEST *&#160;</td>
          <td class="paramname"><em>pcr_digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute PCR selection and a PCR digest for a PCR value list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcrs</td><td>The list of PCR values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcr_selection</td><td>The selection computed based on the list of PCR values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_alg</td><td>The hash algorithm which is used for the policy computation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcr_digest</td><td>The computed PCR digest corresponding to the passed PCR value list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the PCR selection and the PCR digest could be computed.. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If inappropriate values are detected in the input data. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94fb35f081f18d75170cb6b304c508e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94fb35f081f18d75170cb6b304c508e7">&#9670;&nbsp;</a></span>ifapi_compute_quote_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_compute_quote_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>sig_key_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_ATTEST *&#160;</td>
          <td class="paramname"><em>tpm_quoted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>quoteInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the JSON representation of quote information.</p>
<p>The attest generated by a TPM quote will be converted into a JSON representation together with the signature scheme of the key used for the quote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_key_object</td><td>The key object which was used for the quote. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tpm_quoted</td><td>The attest produced by the quote. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quoteInfo</td><td>The character string with the JSON representation of the attest together with the signing schemed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the conversion was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If an invalid value is detected during serialisation. </td></tr>
    <tr><td class="paramname">Possible</td><td>error codes of the unmarshaling function. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an internal error occurred. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2594c1a26a3b169c3256cd6835138b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2594c1a26a3b169c3256cd6835138b2a">&#9670;&nbsp;</a></span>ifapi_copy_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> * ifapi_copy_policy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_p_m_s___p_o_l_i_c_y.html">TPMS_POLICY</a> *&#160;</td>
          <td class="paramname"><em>from_policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_policy</td><td>the policy to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>new policy or NULL if not enough memory was available. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad44614f72af8b4a5f3d1184fc047dbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad44614f72af8b4a5f3d1184fc047dbfa">&#9670;&nbsp;</a></span>ifapi_create_dirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_create_dirs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>supdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create sub-directories in a certain directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">supdir</td><td>The directory in which the new directories shall be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path containing one or more sub-directories.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the directories were created. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>If the linked list with the sub-directories cannot be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If a directory cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5cb7f72dcfe7a40f7d85f59d4a2da6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5cb7f72dcfe7a40f7d85f59d4a2da6f">&#9670;&nbsp;</a></span>ifapi_extend_vpcr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_extend_vpcr </td>
          <td>(</td>
          <td class="paramtype">TPM2B_DIGEST *&#160;</td>
          <td class="paramname"><em>vpcr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMI_ALG_HASH&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_i_f_a_p_i___e_v_e_n_t.html">IFAPI_EVENT</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute new PCR value from a part of an event list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vpcr</td><td>The old and the new PCR value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bank</td><td>The bank corresponding to value of the event list which will be used for computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The event list with the values which were extended for a certain bank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if the bank was not found in the event list. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an error occurs in the crypto library </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga468cc3feb1cd0f5055824e2c63f2393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga468cc3feb1cd0f5055824e2c63f2393c">&#9670;&nbsp;</a></span>ifapi_filter_pcr_selection_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_filter_pcr_selection_by_index </td>
          <td>(</td>
          <td class="paramtype">TPML_PCR_SELECTION *&#160;</td>
          <td class="paramname"><em>pcr_selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TPM2_HANDLE *&#160;</td>
          <td class="paramname"><em>pcr_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pcr_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce a PCR selection to a single pcr.</p>
<p>This includes two steps: clearing all bits but the selected and clearing empty hashalg lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pcr_selection</td><td>The pcr selection to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcr_index</td><td>The only PCR to remain selected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcr_count</td><td>The size of the pcr list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the filtering was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if no pcr remain selected or the pcr selection is malformed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6dc3ed8ed2ca9dc76a41efa4806f83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6dc3ed8ed2ca9dc76a41efa4806f83e">&#9670;&nbsp;</a></span>ifapi_free_node_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifapi_free_node_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__node.html">NODE_OBJECT_T</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free linked list of IFAPI objects (link nodes only).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the first node of the linked list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6797d934eb61443e545844db65ae5f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6797d934eb61443e545844db65ae5f72">&#9670;&nbsp;</a></span>ifapi_free_object_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifapi_free_object_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__node.html">NODE_OBJECT_T</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free linked list of IFAPI objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the first node of the linked list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2b9617854be3d5bb2d8e0de2bf04ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2b9617854be3d5bb2d8e0de2bf04ec8">&#9670;&nbsp;</a></span>ifapi_get_curl_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ifapi_get_curl_buffer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get byte buffer from file system or web via curl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The url of the resource. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer retrieved via the url. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_size</td><td>The size of the retrieved object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if buffer could be retrieved. </td></tr>
    <tr><td class="paramname">-1</td><td>if an error did occur </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb8ce715f4021037bc39fc1f7eb8279e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8ce715f4021037bc39fc1f7eb8279e">&#9670;&nbsp;</a></span>ifapi_get_hierary_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___e_s_y_s___t_r.html#ga65d10db3b0b31fcd709e692f1545d30f">ESYS_TR</a> ifapi_get_hierary_handle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get ESYS handle for a hierarchy path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>ESAPI handle for the hierarchy defined in path. </td></tr>
    <tr><td class="paramname">0</td><td>if not handle can be assigned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga034274af7fde7ae684afd4b5b3237b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga034274af7fde7ae684afd4b5b3237b26">&#9670;&nbsp;</a></span>ifapi_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_get_name </td>
          <td>(</td>
          <td class="paramtype">TPMT_PUBLIC *&#160;</td>
          <td class="paramname"><em>publicInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_NAME *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the name of a TPM transient or persistent object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publicInfo</td><td>The public information of the TPM object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>The computed name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TPM2_RC_SUCCESS</td><td>or one of the possible errors TSS2_FAPI_RC_BAD_VALUE, TSS2_FAPI_RC_MEMORY, TSS2_FAPI_RC_GENERAL_FAILURE. or return codes of SAPI errors. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if an invalid value was passed into the function. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga455326d26b311603d9da63efe79a4dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455326d26b311603d9da63efe79a4dd3">&#9670;&nbsp;</a></span>ifapi_get_nv_start_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_get_nv_start_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2_HANDLE *&#160;</td>
          <td class="paramname"><em>start_nv_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine start index for NV object depending on type.</p>
<p>The value will be determined based on e TCG handle registry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path used for the NV object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">start_nv_index</td><td>The first possible NV index for this type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the index for the path can be determined. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_PATH</td><td>If no handle can be assigned. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa00fd6284ca121583aca052a56f1a2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00fd6284ca121583aca052a56f1a2d4">&#9670;&nbsp;</a></span>ifapi_get_quote_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_get_quote_info </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>quoteInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_ATTEST *&#160;</td>
          <td class="paramname"><em>tpm_quoted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_a_p_i___q_u_o_t_e___i_n_f_o.html">FAPI_QUOTE_INFO</a> *&#160;</td>
          <td class="paramname"><em>fapi_quote_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize the JSON representation of FAPI quote information.</p>
<p>The JSON representation of FAPI quote information will be deserialized to a <a class="el" href="struct_f_a_p_i___q_u_o_t_e___i_n_f_o.html">FAPI_QUOTE_INFO</a> structure and also the TPM2B version of the attest will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quoteInfo</td><td>The JSON representation if the quote information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tpm_quoted</td><td>The marhaled version of the attest structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fapi_quote_info</td><td>The quote information structure used by FAPI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>If the deserialization was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If an invalid value is detected during deserialisation. </td></tr>
    <tr><td class="paramname">Possible</td><td>error codes of the marshaling function. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e34498859d879598ddc08a66f15403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e34498859d879598ddc08a66f15403a">&#9670;&nbsp;</a></span>ifapi_hierarchy_path_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_hierarchy_path_p </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether path describes a hierarchy object.</p>
<p>It will be checked whether the path describes a hierarch. A key path with a hierarchy will not deliver true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the path describes a hierarchy. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93336bf06e87954a0e5ddc1616f9e377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93336bf06e87954a0e5ddc1616f9e377">&#9670;&nbsp;</a></span>ifapi_init_hierarchy_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifapi_init_hierarchy_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_s_y_s___t_r.html#ga65d10db3b0b31fcd709e692f1545d30f">ESYS_TR</a>&#160;</td>
          <td class="paramname"><em>esys_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the internal representation of a FAPI hierarchy object.</p>
<p>The object will be cleared and the type of the general fapi object will be set to hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hierarchy</td><td>The caller allocated hierarchy object. The name of the object will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esys_handle</td><td>The ESAPI handle of the hierarchy which will be added to to the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga276eeabb66eb1eb9136234505536f23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276eeabb66eb1eb9136234505536f23c">&#9670;&nbsp;</a></span>ifapi_null_primary_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ifapi_null_primary_p </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether path is a primary in the null hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the path describes a null hierarchy primary. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7667bcd54362a38007d58a2918f7635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7667bcd54362a38007d58a2918f7635">&#9670;&nbsp;</a></span>ifapi_object_cmp_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_object_cmp_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a nv or key object has a certain name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object (has to be checked whether it's a key). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name to be compared. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">equal</td><td>If the two names are equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESSS</td><td>if name of object can be deserialized. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if an invalid value was passed into the function. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>if an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87cd01f29bf9c4c9535649dd73673ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87cd01f29bf9c4c9535649dd73673ec3">&#9670;&nbsp;</a></span>ifapi_object_cmp_nv_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_object_cmp_nv_public </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nv_public</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a nv object has a certain public info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object (has to be checked whether it's a key). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nv_public</td><td>The NV public data with the NV index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">equal</td><td>If the two names are equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESSS</td><td>if name of object can be deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb1c16328644d62953d4d4836fa95757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1c16328644d62953d4d4836fa95757">&#9670;&nbsp;</a></span>ifapi_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ifapi_path_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the number on nodes in a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the first node of the linked list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the</td><td>number on nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga293580897a76b7519bf018470f3b2171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293580897a76b7519bf018470f3b2171">&#9670;&nbsp;</a></span>ifapi_path_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_path_string </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>supdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a pathname based on a linked list of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The pointer to the generated pathname (callee allocated). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">supdir</td><td>A sup directory will be the prefix of the pathname. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A name which is appended to the result if not NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the function call was a success. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if the memory for the pathname can't be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2161b653a989bab810dc4a9bebb927e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2161b653a989bab810dc4a9bebb927e">&#9670;&nbsp;</a></span>ifapi_path_string_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_path_string_n </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>supdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstr__node.html">NODE_STR_T</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a pathname based on the first n elements of a linked list of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the pointer to the pathname (callee allocated). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">supdir</td><td>a sup directory will be the prefix of the pathname. (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the filename (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of the first elements which will bes used for concatenation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the function call was a success. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if the memory for the pathname can't be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf75cd413d178c3fe513d416d1d3eab11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75cd413d178c3fe513d416d1d3eab11">&#9670;&nbsp;</a></span>ifapi_path_type_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_path_type_p </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether path is of certain type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>sub-string at the beginning of the path to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the path name starts with type. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac76f3965b173b6c0e863ce294f1a4b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76f3965b173b6c0e863ce294f1a4b97">&#9670;&nbsp;</a></span>ifapi_set_key_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_set_key_flags </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_f_a_p_i___k_e_y___t_e_m_p_l_a_t_e.html">IFAPI_KEY_TEMPLATE</a> *&#160;</td>
          <td class="paramname"><em>template</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create template for key creation based on type flags.</p>
<p>Based on passed flags the TPM2B_PUBLIC data which is used for key creation will be adapted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The flags describing the key type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>The flag whether a policy is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">template</td><td>The template including the TPM2B_PUBLIC which will be used for key creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the template can be generated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If an invalid combination of flags was used. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27f2e42fb41260ab89262854aae7077e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27f2e42fb41260ab89262854aae7077e">&#9670;&nbsp;</a></span>ifapi_set_nv_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_set_nv_flags </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_f_a_p_i___n_v___t_e_m_p_l_a_t_e.html">IFAPI_NV_TEMPLATE</a> *&#160;</td>
          <td class="paramname"><em>template</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create template for nv object creation based on type flags.</p>
<p>Based on passed flags the TPM2B_NV_PUBLIC data which is used for key creation will be adapted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The flags describing the nv object type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>The flag whether a policy is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">template</td><td>The template including the TPM2B_NV_PUBLIC which will be used for nv object creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the template can be generated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>If an invalid combination of flags was used. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d6ef478fc320da700c58b4438400c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6ef478fc320da700c58b4438400c07">&#9670;&nbsp;</a></span>ifapi_TPM2B_DIGEST_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPM2B_DIGEST_cmp </td>
          <td>(</td>
          <td class="paramtype">TPM2B_DIGEST *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_DIGEST *&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two variables of type TPM2B_DIGEST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>variable to be compared with in2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td>variable to be compared with in1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the variables are equal. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86d10d7b329dba2cb5ee8400860e14dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d10d7b329dba2cb5ee8400860e14dd">&#9670;&nbsp;</a></span>ifapi_TPM2B_ECC_PARAMETER_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPM2B_ECC_PARAMETER_cmp </td>
          <td>(</td>
          <td class="paramtype">TPM2B_ECC_PARAMETER *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_ECC_PARAMETER *&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two variables of type TPM2B_ECC_PARAMETER.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>variable to be compared with in2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td>variable to be compared with in1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the variables are equal. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9bdb7752a2540102271a76e7e8b6ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9bdb7752a2540102271a76e7e8b6ab0">&#9670;&nbsp;</a></span>ifapi_TPM2B_PUBLIC_KEY_RSA_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPM2B_PUBLIC_KEY_RSA_cmp </td>
          <td>(</td>
          <td class="paramtype">TPM2B_PUBLIC_KEY_RSA *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPM2B_PUBLIC_KEY_RSA *&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two variables of type TPM2B_PUBLIC_KEY_RSA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>variable to be compared with in2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td>variable to be compared with in1</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the variables are equal. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63fac7d0a838e596df0f0685bddf2fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63fac7d0a838e596df0f0685bddf2fff">&#9670;&nbsp;</a></span>ifapi_tpm_to_fapi_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC ifapi_tpm_to_fapi_signature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>sig_key_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMT_SIGNATURE *&#160;</td>
          <td class="paramname"><em>tpm_signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>signatureSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute signature as byte array and signature size in DER format.</p>
<p>For ECC signatures the conversion to DER is necessary, for RSA the buffer of the TPM2B has already DER format. parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_key_object</td><td>The signing key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tpm_signature</td><td>the signature in TPM format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>The byte array of the signature (callee allocated). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signatureSize</td><td>The size of the byte array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESSS</td><td>if the conversion was successful. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>if not enough memory can be allocated. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_GENERAL_FAILURE</td><td>If an internal error occurs, which is not covered by other return codes (e.g. a unexpected openssl error). </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_VALUE</td><td>if an invalid value was passed into the function. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_BAD_REFERENCE</td><td>a invalid null pointer is passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66b6fe34ea1c69e392dfd088fad80166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b6fe34ea1c69e392dfd088fad80166">&#9670;&nbsp;</a></span>ifapi_TPMS_ECC_POINT_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPMS_ECC_POINT_cmp </td>
          <td>(</td>
          <td class="paramtype">TPMS_ECC_POINT *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMS_ECC_POINT *&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two variables of type TPMS_ECC_POINT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>variable to be compared with in2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td>variable to be compared with in1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the variables are equal. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00af0193f671174e217ac6be45254aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00af0193f671174e217ac6be45254aa3">&#9670;&nbsp;</a></span>ifapi_TPMT_PUBLIC_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPMT_PUBLIC_cmp </td>
          <td>(</td>
          <td class="paramtype">TPMT_PUBLIC *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMT_PUBLIC *&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the PUBLIC_ID stored in two TPMT_PUBLIC structures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>the public data with the unique data to be compared with: </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the variables are equal. </td></tr>
    <tr><td class="paramname">false</td><td>if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga238cee88773a3aadffac8661be198796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga238cee88773a3aadffac8661be198796">&#9670;&nbsp;</a></span>ifapi_TPMU_PUBLIC_ID_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ifapi_TPMU_PUBLIC_ID_cmp </td>
          <td>(</td>
          <td class="paramtype">TPMU_PUBLIC_ID *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>selector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPMU_PUBLIC_ID *&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>selector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two variables of type TPMU_PUBLIC_ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in1</td><td>variable to be compared with in2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selector1</td><td>key type of first key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in2</td><td>variable to be compared with in1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selector2</td><td>key type of second key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if variables are equal. </dd>
<dd>
false if not. </dd></dl>

</div>
</div>
<a id="gab66902b2561636af5a982927d5aef44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66902b2561636af5a982927d5aef44d">&#9670;&nbsp;</a></span>init_string_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstr__node.html">NODE_STR_T</a> * init_string_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a linked list of strings.</p>
<p>free string in the list object will be set to true. If the list will be extended by sub-string which are part of this strin free_string has to be set to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string for the first element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the</td><td>initial node of the linked list. </td></tr>
    <tr><td class="paramname">NULL</td><td>if the list cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74e845a3e57021fc1c25684718618075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74e845a3e57021fc1c25684718618075">&#9670;&nbsp;</a></span>object_with_auth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool object_with_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___i_f_a_p_i___o_b_j_e_c_t.html">IFAPI_OBJECT</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether authentication with an auth value is needed ro an object..</p>
<p>In the key store the information whether an auth value was provided for an object is saved. Thus the it is possible to decide whether the auth value callback is required for authentication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object which has to be checked..</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If an auth value was provided. </td></tr>
    <tr><td class="paramname">false</td><td>If not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0552a0622791311be53958ad74fbdec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0552a0622791311be53958ad74fbdec7">&#9670;&nbsp;</a></span>push_object_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSS2_RC push_object_to_list </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__node.html">NODE_OBJECT_T</a> **&#160;</td>
          <td class="paramname"><em>object_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a object as first element to a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object to be added. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">object_list</td><td>The linked list to be extended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TSS2_RC_SUCCESS</td><td>if the object was added. </td></tr>
    <tr><td class="paramname">TSS2_FAPI_RC_MEMORY</td><td>If memory for the list extension cannot be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03902900f256d64ddfffaf393e8a093f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03902900f256d64ddfffaf393e8a093f">&#9670;&nbsp;</a></span>split_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstr__node.html">NODE_STR_T</a> * split_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides str into substrings based on a delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>the string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>the delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>linked list of substrings. </td></tr>
    <tr><td class="paramname">NULL</td><td>if the list cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92db3457377cf6fa25ca10bfcc714b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92db3457377cf6fa25ca10bfcc714b17">&#9670;&nbsp;</a></span>vasprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vasprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to allocated string.</p>
<p>A list of parameters will be printed to an allocated string according to the format description in the first parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>The allocated output string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The format string (printf formats can be used.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The list of objects to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>The size of the string ff the printing was successful. </td></tr>
    <tr><td class="paramname">-1</td><td>if not enough memory can be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
