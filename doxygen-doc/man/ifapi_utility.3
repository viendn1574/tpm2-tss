.TH "ifapi_utility" 3 "Mon May 15 2023" "Version 4.0.1-44-g8699ab39" "tpm2-tss" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ifapi_utility
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBfull_path_to_fapi_path\fP (\fBIFAPI_KEYSTORE\fP *keystore, char *path)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_authorize_object\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP *object, \fBESYS_TR\fP *session)"
.br
.ti -1c
.RI "TPM2_RC \fBifapi_capability_get\fP (\fBFAPI_CONTEXT\fP *context, TPM2_CAP capability, UINT32 count, TPMS_CAPABILITY_DATA **capability_data)"
.br
.ti -1c
.RI "TPM2_RC \fBifapi_capability_init\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_change_auth_hierarchy\fP (\fBFAPI_CONTEXT\fP *context, \fBESYS_TR\fP handle, \fBIFAPI_OBJECT\fP *hierarchy_object, TPM2B_AUTH *newAuthValue)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_change_policy_hierarchy\fP (\fBFAPI_CONTEXT\fP *context, \fBESYS_TR\fP handle, \fBIFAPI_OBJECT\fP *hierarchy_object, \fBTPMS_POLICY\fP *policy)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_cleanup_session\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_esys_serialize_object\fP (\fBESYS_CONTEXT\fP *ectx, \fBIFAPI_OBJECT\fP *object)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_flush_object\fP (\fBFAPI_CONTEXT\fP *context, \fBESYS_TR\fP handle)"
.br
.ti -1c
.RI "void \fBifapi_flush_policy_session\fP (\fBFAPI_CONTEXT\fP *context, \fBESYS_TR\fP session, TSS2_RC r)"
.br
.ti -1c
.RI "void \fBifapi_free_object\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP **object)"
.br
.ti -1c
.RI "void \fBifapi_free_objects\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_certificates\fP (\fBFAPI_CONTEXT\fP *context, UINT32 min_handle, UINT32 max_handle, \fBNODE_OBJECT_T\fP **cert_list)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_description\fP (\fBIFAPI_OBJECT\fP *object, char **description)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_free_handle_async\fP (\fBFAPI_CONTEXT\fP *fctx, TPM2_HANDLE *handle)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_free_handle_finish\fP (\fBFAPI_CONTEXT\fP *fctx, TPM2_HANDLE *handle, TPM2_HANDLE max)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_json\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP *object, char **json_string)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_random\fP (\fBFAPI_CONTEXT\fP *context, size_t numBytes, uint8_t **data)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_session_async\fP (\fBESYS_CONTEXT\fP *esys, \fBESYS_TR\fP saltkey, const \fBIFAPI_PROFILE\fP *profile, TPMI_ALG_HASH hashAlg)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_session_finish\fP (\fBESYS_CONTEXT\fP *esys, \fBESYS_TR\fP *session, TPMA_SESSION flags)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_sessions_async\fP (\fBFAPI_CONTEXT\fP *context, IFAPI_SESSION_TYPE session_flags, TPMA_SESSION attribute_flags1, TPMA_SESSION attribute_flags2)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_sessions_finish\fP (\fBFAPI_CONTEXT\fP *context, const \fBIFAPI_PROFILE\fP *profile, TPMI_ALG_HASH hash_alg)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_sig_scheme\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP *object, char const *padding, TPM2B_DIGEST *digest, TPMT_SIG_SCHEME *sig_scheme)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_init_primary_async\fP (\fBFAPI_CONTEXT\fP *context, TSS2_KEY_TYPE ktype)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_initialize_object\fP (\fBESYS_CONTEXT\fP *ectx, \fBIFAPI_OBJECT\fP *object)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_key_create\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_KEY_TEMPLATE\fP *template)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_key_create_prepare\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath, char const *policyPath)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_key_create_prepare_auth\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath, char const *policyPath, char const *authValue)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_key_create_prepare_sensitive\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath, char const *policyPath, size_t dataSize, char const *authValue, uint8_t const *data)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_key_sign\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP *sig_key_object, char const *padding, TPM2B_DIGEST *digest, TPMT_SIGNATURE **tpm_signature, char **publicKey, char **certificate)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_key\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath, \fBIFAPI_OBJECT\fP **key_object)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_key_async\fP (\fBFAPI_CONTEXT\fP *context, size_t position)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_key_finish\fP (\fBFAPI_CONTEXT\fP *context, bool flush_parent)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_keys_async\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_keys_finish\fP (\fBFAPI_CONTEXT\fP *context, bool flush_parent, \fBESYS_TR\fP *handle, \fBIFAPI_OBJECT\fP **key_object)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_primary_async\fP (\fBFAPI_CONTEXT\fP *context, char *path)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_primary_finish\fP (\fBFAPI_CONTEXT\fP *context, \fBESYS_TR\fP *handle)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_merge_profile_into_nv_template\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_NV_TEMPLATE\fP *template)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_merge_profile_into_template\fP (const \fBIFAPI_PROFILE\fP *profile, \fBIFAPI_KEY_TEMPLATE\fP *template)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_non_tpm_mode_init\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_nv_read\fP (\fBFAPI_CONTEXT\fP *context, uint8_t **data, size_t *size)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_nv_write\fP (\fBFAPI_CONTEXT\fP *context, char *nvPath, size_t param_offset, uint8_t const *data, size_t size)"
.br
.ti -1c
.RI "void \fBifapi_primary_clean\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "void \fBifapi_session_clean\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_session_init\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_set_auth\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_OBJECT\fP *auth_object, const char *description)"
.br
.ti -1c
.RI "void \fBifapi_set_description\fP (\fBIFAPI_OBJECT\fP *object, char *description)"
.br
.ti -1c
.RI "\fBIFAPI_OBJECT\fP * \fBifapi_allocate_object\fP (\fBFAPI_CONTEXT\fP *context)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_create_primary\fP (\fBFAPI_CONTEXT\fP *context, \fBIFAPI_KEY_TEMPLATE\fP *template)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_get_key_properties\fP (\fBFAPI_CONTEXT\fP *context, char const *key_path, bool *is_primary, bool *in_null_hierarchy)"
.br
.ti -1c
.RI "const char * \fBifapi_get_object_path\fP (\fBIFAPI_OBJECT\fP *object)"
.br
.ti -1c
.RI "TSS2_RC \fBifapi_load_parent_keys_async\fP (\fBFAPI_CONTEXT\fP *context, char const *keyPath)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides internal utility functions\&. 
.SH "Function Documentation"
.PP 
.SS "void full_path_to_fapi_path (\fBIFAPI_KEYSTORE\fP * keystore, char * path)"
Convert full FAPI path to relative path\&.
.PP
The relative path will be copied directly into the passed object\&.
.PP
\fBParameters\fP
.RS 4
\fIkeystore\fP The key directories and default profile\&. 
.br
\fIpath\fP The absolute path\&. 
.RE
.PP

.SS "ifapi_allocate_object (\fBFAPI_CONTEXT\fP * context)"
Allocate ifapi object and store the result in a linked list\&.
.PP
Allocated ifapi objects will be recorded in the context\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP allocated ifapi object\&. 
.br
\fINULL\fP if the object cannot be allocated\&. 
.RE
.PP

.SS "TSS2_RC ifapi_authorize_object (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP * object, \fBESYS_TR\fP * session)"
State machine to authorize a key, a NV object of a hierarchy\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fIobject\fP The FAPI object\&. 
.br
\fIsession\fP The session which can be used for object authorization\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the authorization is successful 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the policy store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If a policy for a certain path was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for the policy execution fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.RE
.PP

.SS "TPM2_RC ifapi_capability_get (\fBFAPI_CONTEXT\fP * context, TPM2_CAP capability, UINT32 count, TPMS_CAPABILITY_DATA ** capability_data)"
State machine for receiving TPM capability information\&.
.PP
The state machine shares the state with the FAPI function Fapi_GetInfo\&. context->state == GET_INFO_GET_CAP_MORE signals that more capability data can be retrieved\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIcapability\fP The capability to be retrieved\&. 
.br
\fIcount\fP The maximal number of items that should be retrieved\&. 
.br
\fIcapability_data\fP The retrieved capability information\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If all capability data is retrieved\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if more capability data is available\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.RE
.PP

.SS "TPM2_RC ifapi_capability_init (\fBFAPI_CONTEXT\fP * context)"
Prepare the receiving of capability data\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\&.\fP 
.RE
.PP

.SS "TSS2_RC ifapi_change_auth_hierarchy (\fBFAPI_CONTEXT\fP * context, \fBESYS_TR\fP handle, \fBIFAPI_OBJECT\fP * hierarchy_object, TPM2B_AUTH * newAuthValue)"
State machine for changing the hierarchy authorization\&.
.PP
First it will be tried to set the auth value of the hierarchy with a 'null' authorization\&. If this trial is not successful it will be tried to authorize the hierarchy via a callback\&. If an not null auth value is passed with_auth is set to yes for the object otherwise to no\&. So for later authorizations it will be clear whether null authorization is possible or not\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP The ESAPI handle of the hierarchy\&. 
.br
\fIhierarchy_object\fP The internal FAPI representation of a hierarchy\&. 
.br
\fInewAuthValue\fP The new authorization for the hierarchy\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occured\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occured while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.RE
.PP

.SS "TSS2_RC ifapi_change_policy_hierarchy (\fBFAPI_CONTEXT\fP * context, \fBESYS_TR\fP handle, \fBIFAPI_OBJECT\fP * hierarchy_object, \fBTPMS_POLICY\fP * policy)"
State machine for changing the policy of a hierarchy\&.
.PP
Based on a passed policy the policy digest will be computed\&. First it will be tried to set the policy of the hierarchy with a 'null' authorization\&. If this trial is not successful it will be tried to authorize the hierarchy via a callback\&. If an not null auth value is passed with_auth is set to yes for the object otherwise to no\&. So for later authorizations it will be clear whether null authorization is possible or not\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP The ESAPI handle of the hierarchy\&. 
.br
\fIhierarchy_object\fP The internal FAPI representation of a hierarchy\&. 
.br
\fIpolicy\fP The new policy assigned to the hierarchy\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is not covered by other return codes\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during policy calculation\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the policy store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If an object needed for policy calculation was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP
< no path needed
.SS "TSS2_RC ifapi_cleanup_session (\fBFAPI_CONTEXT\fP * context)"
State machine for asynchronous cleanup of a FAPI session\&.
.PP
Used sessions and the SRK will be flushed\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP storing the used handles\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.RE
.PP

.SS "ifapi_create_primary (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_KEY_TEMPLATE\fP * template)"
Creation of a primary key\&.
.PP
Depending on the flags stored in the context the creation of a primary key will be prepared\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fItemplate\fP The template which defines the key attributes and whether the key will be persistent\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if a wrong type was passed\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occurred while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_PATH_ALREADY_EXISTS\fP if the object already exists in object store\&. 
.RE
.PP

.SS "TSS2_RC ifapi_esys_serialize_object (\fBESYS_CONTEXT\fP * ectx, \fBIFAPI_OBJECT\fP * object)"
Serialize persistent objects into buffer of keystore object\&.
.PP
NV objects and persistent keys will serialized via the ESYS API to enable reconstruction durinng loading from keystore\&.
.PP
\fBParameters\fP
.RS 4
\fIectx\fP The ESAPI context\&. 
.br
\fIobject\fP The nv object or the key\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP if the function call was a success\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occured\&. 
.RE
.PP

.SS "TSS2_RC ifapi_flush_object (\fBFAPI_CONTEXT\fP * context, \fBESYS_TR\fP handle)"
State machine for flushing objects\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP of the object to be flushed\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.RE
.PP

.SS "void ifapi_flush_policy_session (\fBFAPI_CONTEXT\fP * context, \fBESYS_TR\fP session, TSS2_RC r)"
Check whether policy session has to be flushed\&.
.PP
Policy sessions with cleared continue session flag are not flushed in error cases\&. Therefore the return code will be checked and if a policy session was used the session will be flushed if the command was not executed successfully\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fIsession\fP the session to be checked whether flush is needed\&. 
.br
\fIr\fP The return code of the command using the session\&. 
.RE
.PP

.SS "void ifapi_free_object (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP ** object)"
Free ifapi a object stored in the context\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIobject\fP The object which should be removed from the the linked list stored in context\&. 
.RE
.PP

.SS "void ifapi_free_objects (\fBFAPI_CONTEXT\fP * context)"
Free all ifapi objects stored in the context\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_certificates (\fBFAPI_CONTEXT\fP * context, UINT32 min_handle, UINT32 max_handle, \fBNODE_OBJECT_T\fP ** cert_list)"
Get certificates stored in NV ram\&.
.PP
The NV handles in the certificate range are determined\&. The corresponding certificates are read out and stored in a linked list\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. The sub context for NV reading will be used\&. 
.br
\fImin_handle\fP The first possible handle in the handle range\&. 
.br
\fImax_handle\fP Maximal handle to filter out the handles not in the handle range for certificates\&. 
.br
\fIcert_list\fP The callee allocates linked list of certificates\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&.
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occurred while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_description (\fBIFAPI_OBJECT\fP * object, char ** description)"
Get description of an internal FAPI object\&.
.PP
\fBParameters\fP
.RS 4
\fIobject\fP The object with the description\&. 
.br
\fIdescription\fP The callee allocated description\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If a copy of the description can be returned or if no description exists\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP in the copy cannot be allocated\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_free_handle_async (\fBFAPI_CONTEXT\fP * fctx, TPM2_HANDLE * handle)"
Preparation for getting a free handle after a start handle number\&.
.PP
\fBParameters\fP
.RS 4
\fIfctx\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP The start value for handle search\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_free_handle_finish (\fBFAPI_CONTEXT\fP * fctx, TPM2_HANDLE * handle, TPM2_HANDLE max)"
Execution of get capability until a free handle is found\&.
.PP
The get capability method is called until a free handle is found or the max number of trials passe to the function is exeeded\&.
.PP
\fBParameters\fP
.RS 4
\fIfctx\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP The free handle\&. 
.br
\fImax\fP The maximal number of trials\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_NV_TOO_SMALL\fP if too many NV handles are defined\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_json (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP * object, char ** json_string)"
Get json encoding for FAPI object\&.
.PP
A json representation which can be used for exporting of a FAPI object will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIobject\fP The object to be serialized\&. 
.br
\fIjson_string\fP The json string created by the deserialzation function (callee-allocated)\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the serialization was successful\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during serialization\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP If a NULL pointer was passed for the object\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.RE
.PP

.SS "ifapi_get_key_properties (\fBFAPI_CONTEXT\fP * context, char const * key_path, bool * is_primary, bool * in_null_hierarchy)"
Determine key properties (primary, null hierarchy)\&.
.PP
It will be checked whether a path is the path of a primary key, and whether it's a key in null hiearchy
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkey_path\fP the key path\&. 
.br
\fIis_primary\fP if key path is the path of a primary\&. 
.br
\fIin_null_hierarchy\fP if key is a null hierarchy key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation is successful\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "ifapi_get_object_path (\fBIFAPI_OBJECT\fP * object)"
Get relative path of a FAPI object\&.
.PP
\fBParameters\fP
.RS 4
\fIobject\fP The internal FAPI object\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP relative path of the object\&. 
.br
\fINULL\fP if no path is available\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_random (\fBFAPI_CONTEXT\fP * context, size_t numBytes, uint8_t ** data)"
State machine to retrieve random data from TPM\&.
.PP
If the buffer size exceeds the maximum size, several ESAPI calls are made\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fInumBytes\fP Number of random bytes to be computed\&. 
.br
\fIdata\fP The random data\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If random data can be computed\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_session_async (\fBESYS_CONTEXT\fP * esys, \fBESYS_TR\fP saltkey, const \fBIFAPI_PROFILE\fP * profile, TPMI_ALG_HASH hashAlg)"
Preparation for getting a session handle\&.
.PP
The corresponding async call be executed and a session secret for encryption TPM2B parameters will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIesys\fP The \fBESYS_CONTEXT\fP\&. 
.br
\fIsaltkey\fP The key which will be used for the encryption of the session secret\&. 
.br
\fIprofile\fP The FAPI profile will be used to adjust the sessions symmetric parameters\&. 
.br
\fIhashAlg\fP The hash algorithm used for the session\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_session_finish (\fBESYS_CONTEXT\fP * esys, \fBESYS_TR\fP * session, TPMA_SESSION flags)"
Call for getting a session handle and adjust session parameters\&.
.PP
\fBParameters\fP
.RS 4
\fIesys\fP The \fBESYS_CONTEXT\fP\&. 
.br
\fIsession\fP The session handle\&. 
.br
\fIflags\fP The flags to adjust the session attributes\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_sessions_async (\fBFAPI_CONTEXT\fP * context, IFAPI_SESSION_TYPE session_flags, TPMA_SESSION attribute_flags1, TPMA_SESSION attribute_flags2)"
Prepare the session creation of a FAPI command\&.
.PP
The initial state of the state machine for session creation will be determined\&. Depending of the session_flags creation of a primary for the encryption of the session secret can be adjusted\&. The session passed session attributes will be used for the ESAPI command Esys_TRSess_SetAttributes\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP storing the used handles\&. 
.br
\fIsession_flags\fP The flags to adjust used session and encryption key\&. With IFAPI_SESSION1 and IFAPI_SESSION2 the session creation for sesion1 and session2 can be activated, IFAPI_SESSION_GENEK triggers the creation of the primary for session secret encryption\&. 
.br
\fIattribute_flags1\fP The attributes used for session1\&. 
.br
\fIattribute_flags2\fP The attributes used for session2\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if the hierarchy file or the primary key file does not exist\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. of the primary\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occurred while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_sessions_finish (\fBFAPI_CONTEXT\fP * context, const \fBIFAPI_PROFILE\fP * profile, TPMI_ALG_HASH hash_alg)"
State machine for the session creation of a FAPI command\&.
.PP
The sessions needed for a FAPI command will be created\&. If needed also the primary key for session encryption will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP storing the used handles\&. 
.br
\fIprofile\fP The FAPI profile will be used to adjust session parameters\&. 
.br
\fIhash_alg\fP The hash algorithm used for the session\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an I/O error was encountered\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP

.SS "TSS2_RC ifapi_get_sig_scheme (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP * object, char const * padding, TPM2B_DIGEST * digest, TPMT_SIG_SCHEME * sig_scheme)"
Get signature scheme for key\&.
.PP
If padding is passed the scheme will be derived from paddint otherwise the scheme form object will be used\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIobject\fP The internal FAPI object of the key\&. 
.br
\fIpadding\fP The strings RSA_SSA or RSA_PSS will be converted into the TSS constants used for the signing scheme\&. 
.br
\fIdigest\fP The digest size will be used to determine the hashalg for the signature scheme\&. 
.br
\fIsig_scheme\fP The computed signature scheme\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_FAPI_RC_BAD_VALUE\fP If the digest size is not appropriate\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.RE
.PP

.SS "TSS2_RC ifapi_init_primary_async (\fBFAPI_CONTEXT\fP * context, TSS2_KEY_TYPE ktype)"
Prepare the creation of a primary key\&.
.PP
Depending on the parameters the creation of an endorsement or storage root key will be prepared\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIktype\fP The type of key TSS2_EK or TSS2_SRK\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if a wrong type was passed\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occurred while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP
< no path needed
.SS "TSS2_RC ifapi_initialize_object (\fBESYS_CONTEXT\fP * ectx, \fBIFAPI_OBJECT\fP * object)"
Initialize the part of an IFAPI_OBJECT which is not serialized\&.
.PP
For persistent objects the correspodning ESYS object will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIectx\fP The ESYS context\&. 
.br
\fIobject\fP the deserialzed binary object\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP if the function call was a success\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if the json object can't be deserialized\&. 
.RE
.PP

.SS "TSS2_RC ifapi_key_create (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_KEY_TEMPLATE\fP * template)"
State machine for key creation\&.
.PP
The function for the preparation of the key have to called before the state machine can be activated\&. The linked list for the used directories must be available in the FAPI context\&. It will be checked whether the object already exists in key store and the FAPI context will be initialized appropriate for key creation\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fItemplate\fP The template which defines the key attributes and whether the key will be persistent\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the key could be generated\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is not covered by other return codes\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the policy store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If an object needed for creation or authentication was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for creation fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_PATH_ALREADY_EXISTS\fP if the object already exists in object store\&. 
.RE
.PP

.SS "TSS2_RC ifapi_key_create_prepare (\fBFAPI_CONTEXT\fP * context, char const * keyPath, char const * policyPath)"
Prepare key creation if possible\&.
.PP
It will be checked whether the object already exists in key store and the FAPI context will be initialized appropriate for key creation\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey) 
.br
\fIpolicyPath\fP identifies the policy to be associated with the new key\&. policyPath MAY be NULL\&. If policyPath is NULL then no policy will be associated with the key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation was successful\&. 
.br
\fITSS2_FAPI_RC_PATH_ALREADY_EXISTS\fP If the object with does already exist in keystore\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_NO_TPM\fP if FAPI was initialized in no-TPM-mode via its config file\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_key_create_prepare_auth (\fBFAPI_CONTEXT\fP * context, char const * keyPath, char const * policyPath, char const * authValue)"
Prepare key creation with an auth value\&.
.PP
The auth value will be copied int the FAPI context for later use in key creation\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey) 
.br
\fIpolicyPath\fP identifies the policy to be associated with the new key\&. policyPath MAY be NULL\&. If policyPath is NULL then no policy will be associated with the key\&. 
.br
\fIauthValue\fP The authentication value of the key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation was successful\&. 
.br
\fITSS2_FAPI_RC_PATH_ALREADY_EXISTS\fP If the object with does already exist in keystore\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_NO_TPM\fP if FAPI was initialized in no-TPM-mode via its config file\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_key_create_prepare_sensitive (\fBFAPI_CONTEXT\fP * context, char const * keyPath, char const * policyPath, size_t dataSize, char const * authValue, uint8_t const * data)"
Prepare key creation with an auth value and sensitive data\&.
.PP
The auth value and the sensitive data will be copied int the FAPI context for later use in key creation\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey) 
.br
\fIpolicyPath\fP identifies the policy to be associated with the new key\&. policyPath MAY be NULL\&. If policyPath is NULL then no policy will be associated with the key\&. 
.br
\fIdataSize\fP The size of the sensitive data\&. 
.br
\fIauthValue\fP The authentication value of the key\&. 
.br
\fIdata\fP The sensitive data\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation was successful\&. 
.br
\fITSS2_FAPI_RC_PATH_ALREADY_EXISTS\fP If the object with does already exist in keystore\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_NO_TPM\fP if FAPI was initialized in no-TPM-mode via its config file\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_key_sign (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP * sig_key_object, char const * padding, TPM2B_DIGEST * digest, TPMT_SIGNATURE ** tpm_signature, char ** publicKey, char ** certificate)"
State machine for signing operation\&.
.PP
The key used for signing will be authorized and the signing of the passed data will be executed\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIsig_key_object\fP The Fapi key object which will be used to sign the passed digest\&. 
.br
\fIpadding\fP is the padding algorithm used\&. Possible values are RSA_SSA, RSA_PPSS (case insensitive)\&. padding MAY be NULL\&. 
.br
\fIdigest\fP is the data to be signed, already hashed\&. digest MUST NOT be NULL\&. 
.br
\fItpm_signature\fP returns the signature in binary form (DER format)\&. tpm_signature MUST NOT be NULL (callee-allocated)\&. 
.br
\fIpublicKey\fP is the public key of the signing key in PEM format\&. publicKey is callee allocated and MAY be NULL\&. 
.br
\fIcertificate\fP is the certificate associated with the signing key in PEM format\&. certificate MAY be NULL\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the signing was successful\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is not covered by other return codes\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the policy store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If a policy for a certain path was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_BAD_TEMPLATE\fP In a invalid policy is loaded during execution\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for policy execution fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_key (\fBFAPI_CONTEXT\fP * context, char const * keyPath, \fBIFAPI_OBJECT\fP ** key_object)"
Load a key and initialize profile and session for ESAPI execution\&.
.PP
This state machine prepares the session for key loading\&. Some session related parameters will be taken from profile\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey) 
.br
\fIkey_object\fP The callee allocated internal representation of a key object\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the key was loaded successfully\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is not covered by other return codes\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the object store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If a policy or key was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for policy execution fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_key_async (\fBFAPI_CONTEXT\fP * context, size_t position)"
Initialize state machine for loading a key\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fIposition\fP the position of the key in path list stored in context->loadKey\&.path_list\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_key_finish (\fBFAPI_CONTEXT\fP * context, bool flush_parent)"
State machine for loading a key\&.
.PP
A stack with all sup keys will be created and decremented during the loading auf all keys\&. The object of the loaded key will be stored in: context->loadKey\&.auth_object
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fIflush_parent\fP If flush_parent is false parent is only flushed if a new parent is available\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the loading of the key was successful\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is not covered by other return codes\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the policy store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If an object needed for loading or authentication was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for loading fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.RE
.PP
< to avoid scan-build errors\&.
.PP
< to avoid scan-build errors\&.
.SS "TSS2_RC ifapi_load_keys_async (\fBFAPI_CONTEXT\fP * context, char const * keyPath)"
Asynchronous preparation for loading a key and parent keys\&.
.PP
The key loading is prepared\&. The pathname will be extended if possible and a linked list with the directories will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey)
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation is successful\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_keys_finish (\fBFAPI_CONTEXT\fP * context, bool flush_parent, \fBESYS_TR\fP * handle, \fBIFAPI_OBJECT\fP ** key_object)"
Asynchronous finish function for loading a key\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIflush_parent\fP If false the parent of the key to be loaded will not be flushed\&. 
.br
\fIhandle\fP The ESYS handle of the key\&. 
.br
\fIkey_object\fP The object which will be used for the authorization of the loaded key\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an error occurred while accessing the object store\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.RE
.PP

.SS "ifapi_load_parent_keys_async (\fBFAPI_CONTEXT\fP * context, char const * keyPath)"
Asynchronous preparation for loading of the parent keys\&.
.PP
The key loading is prepared\&. The pathname will be extended if possible and a linked list with the directories will be created\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIkeyPath\fP the key path without the parent directories of the key store\&. (e\&.g\&. HE/EK, HS/SRK/mykey)
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the preparation is successful\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if an invalid value was passed into the function\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if a FAPI object path was not found during authorization\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_primary_async (\fBFAPI_CONTEXT\fP * context, char * path)"
Prepare the loading of a primary key from key store\&.
.PP
The asynchronous loading or the key from keystore will be prepared and the path will be stored in the FAPI context\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIpath\fP The FAPI path of the primary key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if a wrong type was passed\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an I/O error was encountered\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if the file does not exist\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP

.SS "TSS2_RC ifapi_load_primary_finish (\fBFAPI_CONTEXT\fP * context, \fBESYS_TR\fP * handle)"
State machine to finalize the loading of a primary key from key store\&.
.PP
The asynchronous loading or the key from keystore will be finalized\&. Afterwards the hierarchy object, which will be used for authorization will be loaded and the ESAPI functions for primary generation will be called if the primary is not persistent\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIhandle\fP The object handle of the primary key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP if a wrong type was passed\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP if the hierarchy file does not exist\&. 
.br
\fITSS2_FAPI_RC_IO_ERROR\fP if an I/O error was encountered\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if memory could not be allocated for path names\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP if an internal error occurred\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a required authorization callback is not set\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP if policy search for a certain policy digest was not successful\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if the path is used in inappropriate context or contains illegal characters\&. 
.RE
.PP

.SS "TSS2_RC ifapi_merge_profile_into_nv_template (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_NV_TEMPLATE\fP * template)"
Merge profile already stored in FAPI context into a NV object template\&.
.PP
The defaults for NV creation which are stored in the FAPI default profile will be merged in the passed templates default values\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP with the default profile\&. 
.br
\fItemplate\fP The template with the default values for the NV object\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.RE
.PP

.SS "TSS2_RC ifapi_merge_profile_into_template (const \fBIFAPI_PROFILE\fP * profile, \fBIFAPI_KEY_TEMPLATE\fP * template)"
Merge profile already stored in FAPI context into a key template\&.
.PP
The defaults for key creation which are stored in the FAPI default profile will be merged in the passed templates default values\&.
.PP
\fBParameters\fP
.RS 4
\fIprofile\fP The profile which will be used to adjust the template\&. 
.br
\fItemplate\fP The template with the default values for the key object\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.RE
.PP

.SS "TSS2_RC ifapi_non_tpm_mode_init (\fBFAPI_CONTEXT\fP * context)"
Prepare session for FAPI command execution without TPM\&.
.PP
It will be checked whether the context of FAPI is initialized and whether no other FAPI command session is running\&. Also some handle variables in the context are initialized\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP if the context is not initialized\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP If a FAPI command session is active\&. 
.RE
.PP

.SS "TSS2_RC ifapi_nv_read (\fBFAPI_CONTEXT\fP * context, uint8_t ** data, size_t * size)"
State machine to read data from the NV ram of the TPM\&.
.PP
The state machine can bes used to read NV data for a given ESAPI object or for a TPM NV index\&. If TPM NV index is used a ESAPI object will be created if the NV index exists\&. If not the size 0 will be returned\&. If a TPM handle is used the initial stat NV_READ_CHECK_HANDLE has to be set: context->nv_cmd\&.nv_read_state\&. Context nv_cmd has to be prepared before the call of this function: With an TPM handle:
.IP "\(bu" 2
tpm_handle The ESAPI handle of the authorization object\&. With an ESYS handle:
.IP "\(bu" 2
auth_index The ESAPI handle of the authorization object\&.
.IP "\(bu" 2
numBytes The number of bytes which should be read\&.
.IP "\(bu" 2
esys_handle The ESAPI handle of the NV object\&.
.PP
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fIdata\fP the data fetched from TPM\&. 
.br
\fIsize\fP The number of bytes requested and fetched\&. will be 0 if a TPM handle is used but the NV index does not exist\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If the data was read successfully\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is
.IP "\(bu" 2
not covered by other return codes\&. 
.PP
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the object store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP If a policy for a certain path was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for the execution fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.RE
.PP

.SS "TSS2_RC ifapi_nv_write (\fBFAPI_CONTEXT\fP * context, char * nvPath, size_t param_offset, uint8_t const * data, size_t size)"
State machine to write data to the NV ram of the TPM\&.
.PP
The NV object will be read from object store and the data will be written by one, or more than one if necessary, ESAPI calls to the NV ram of the TPM\&. The sub context nv_cmd will be prepared:
.IP "\(bu" 2
data The buffer for the data which has to be written
.IP "\(bu" 2
offset The current offset for writing
.IP "\(bu" 2
numBytes The number of bytes which have to be written\&.
.PP
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP for storing all state information\&. 
.br
\fInvPath\fP The fapi path of the NV object\&. 
.br
\fIparam_offset\fP The offset in the NV memory (will be stored in context)\&. 
.br
\fIdata\fP The pointer to the data to be written\&. 
.br
\fIsize\fP The number of bytes to be written\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP If data can be written\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.br
\fITSS2_FAPI_RC_MEMORY\fP if not enough memory can be allocated\&. 
.br
\fITSS2_FAPI_RC_BAD_VALUE\fP If wrong values are detected during execution\&. 
.br
\fITSS2_FAPI_RC_GENERAL_FAILURE\fP If an internal error occurs, which is
.IP "\(bu" 2
not covered by other return codes\&. 
.PP
.br
\fITSS2_FAPI_RC_IO_ERROR\fP If an error occurs during access to the object store\&. 
.br
\fITSS2_FAPI_RC_PATH_NOT_FOUND\fP The nv object or an object needed for authentication was not found\&. 
.br
\fITSS2_FAPI_RC_POLICY_UNKNOWN\fP If policy search for a certain policy digest was not successful\&. 
.br
\fITPM2_RC_BAD_AUTH\fP If the authentication for an object needed for the command execution fails\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP if a needed authorization callback is not defined\&. 
.br
\fITSS2_FAPI_RC_BAD_PATH\fP if a path is used in inappropriate context or contains illegal characters\&. 
.br
\fITSS2_FAPI_RC_TRY_AGAIN\fP if an I/O operation is not finished yet and this function needs to be called again\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP if the context has an asynchronous operation already pending\&. 
.br
\fITSS2_FAPI_RC_KEY_NOT_FOUND\fP if a key was not found\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP a invalid null pointer is passed\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_FAILED\fP if the authorization attempt fails\&. 
.br
\fITSS2_FAPI_RC_NOT_PROVISIONED\fP FAPI was not provisioned\&. 
.RE
.PP

.SS "void ifapi_primary_clean (\fBFAPI_CONTEXT\fP * context)"
Cleanup primary keys in error cases (non asynchronous)\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP storing the used handles\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_ESYS_RC_*\fP possible error codes of ESAPI\&. 
.RE
.PP

.SS "void ifapi_session_clean (\fBFAPI_CONTEXT\fP * context)"
Cleanup FAPI sessions in error cases\&.
.PP
The uses sessions and the SRK (if not persistent) will be flushed non asynchronous in error cases\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.RE
.PP

.SS "TSS2_RC ifapi_session_init (\fBFAPI_CONTEXT\fP * context)"
Prepare session for FAPI command execution\&.
.PP
It will be checked whether the context of FAPI and ESAPI is initialized and whether no other FAPI command session is running\&. Also some handle variables in the context are initialized\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_BAD_REFERENCE\fP if the context is not initialized\&. 
.br
\fITSS2_FAPI_RC_BAD_SEQUENCE\fP If a FAPI command session is active\&. 
.br
\fITSS2_FAPI_RC_NO_TPM\fP if the ESAPI context is not initialized\&. 
.RE
.PP

.SS "TSS2_RC ifapi_set_auth (\fBFAPI_CONTEXT\fP * context, \fBIFAPI_OBJECT\fP * auth_object, const char * description)"
Set authorization value for a FAPI object\&.
.PP
The callback which provides the auth value must be defined\&.
.PP
\fBParameters\fP
.RS 4
\fIcontext\fP The \fBFAPI_CONTEXT\fP\&. 
.br
\fIauth_object\fP The auth value will be assigned to this object\&. 
.br
\fIdescription\fP The description will be passed to the callback which delivers the auth value\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fITSS2_RC_SUCCESS\fP on success\&. 
.br
\fITSS2_FAPI_RC_AUTHORIZATION_UNKNOWN\fP If the callback for getting the auth value is not defined\&. 
.RE
.PP

.SS "void ifapi_set_description (\fBIFAPI_OBJECT\fP * object, char * description)"
Set description of an internal FAPI object\&.
.PP
\fBParameters\fP
.RS 4
\fIobject\fP The object with the description\&. 
.br
\fIdescription\fP The description char strint or NULL\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for tpm2-tss from the source code\&.
